
{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the Affiliate AI Host platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user, matches Firebase Auth UID."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "username": {
          "type": "string",
          "description": "User's username."
        },
        "referredBy": {
          "type": [
            "string",
            "null"
          ],
          "description": "ID of the affiliate who referred this user."
        },
        "isAffiliate": {
          "type": "boolean",
          "description": "Indicates whether the user is an affiliate."
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "The timestamp when the user account was created."
        },
        "subscription": {
          "type": [
            "object",
            "null"
          ],
          "description": "The user's current subscription details.",
          "properties": {
            "tierId": {
              "type": "string"
            },
            "status": {
              "type": "string"
            },
            "startDate": {
              "type": "string",
              "format": "date-time"
            },
            "endDate": {
              "type": [
                "string",
                "null"
              ],
              "format": "date-time"
            }
          }
        },
        "paypalEmail": {
          "type": "string",
          "description": "The user's PayPal email for receiving payouts."
        }
      },
      "required": [
        "id",
        "email",
        "username"
      ]
    },
    "SubscriptionTier": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SubscriptionTier",
      "type": "object",
      "description": "Represents a subscription tier with its associated features and pricing.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the subscription tier."
        },
        "name": {
          "type": "string",
          "description": "Name of the subscription tier (e.g., Starter, Growth, Pro, Enterprise)."
        },
        "dailyPrice": {
          "type": "number",
          "description": "Daily price of the subscription tier."
        },
        "hostingResources": {
          "type": "string",
          "description": "Description of the web hosting resources included in this tier."
        },
        "aiToolsAccess": {
          "type": "string",
          "description": "Description of the AI tools access included in this tier."
        }
      },
      "required": [
        "id",
        "name",
        "dailyPrice"
      ]
    },
    "Subscription": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Subscription",
      "type": "object",
      "description": "Represents a user's subscription to a specific tier.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the subscription."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Subscription)",
          "format": "uuid"
        },
        "subscriptionTierId": {
          "type": "string",
          "description": "Reference to SubscriptionTier. (Relationship: SubscriptionTier 1:N Subscription)"
        },
        "startDate": {
          "type": "string",
          "description": "Date when the subscription started.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "Date when the subscription ends (or null if ongoing).",
          "format": "date-time"
        },
        "paypalSubscriptionId": {
          "type": "string",
          "description": "The id of the user's subscription with paypal."
        }
      },
      "required": [
        "id",
        "userId",
        "subscriptionTierId",
        "startDate"
      ]
    },
    "Referral": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Referral",
      "type": "object",
      "description": "Represents a referral made by an affiliate, which also contains commission details.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the referral record."
        },
        "affiliateId": {
          "type": "string",
          "description": "Reference to the User (affiliate) who made the referral."
        },
        "referredUserId": {
          "type": "string",
          "description": "Reference to the User who was referred."
        },
        "referredUserUsername": {
          "type": "string",
          "description": "Username of the referred user."
        },
        "planPurchased": {
            "type": "string",
            "description": "The name of the subscription plan purchased by the referred user."
        },
        "date": {
          "type": "string",
          "description": "Date when the referral was made.",
          "format": "date-time"
        },
        "commission": {
          "type": "number",
          "description": "Amount of the commission earned from this referral."
        },
        "status": {
          "type": "string",
          "description": "Status of the commission (e.g., 'paid', 'unpaid')."
        },
        "subscriptionId": {
            "type": "string",
            "description": "The ID of the subscription that generated this commission."
        },
        "triggeringUserReferredBy": {
          "type": "string",
          "description": "A write-only field used by security rules to verify the referral without a `get` call. It should contain the UID of the referrer."
        }
      },
      "required": [
        "id",
        "affiliateId",
        "referredUserId",
        "date",
        "commission",
        "status"
      ]
    },
    "Payment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Payment",
      "type": "object",
      "description": "Represents a payment made to an affiliate or by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the payment."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User who received the payment. (Relationship: User 1:N Payment)",
          "format": "uuid"
        },
        "amount": {
          "type": "number",
          "description": "Amount of the payment."
        },
        "paymentDate": {
          "type": "string",
          "description": "Date when the payment was made.",
          "format": "date-time"
        },
        "description": {
          "type": "string",
          "description": "A description of the payment."
        },
        "type": {
          "type": "string",
          "description": "The type of the payment - usually 'commission' or 'payout'.",
          "format": "string"
        }
      },
      "required": [
        "id",
        "userId",
        "amount",
        "paymentDate"
      ]
    },
    "AdminRole": {
      "title": "Admin Role",
      "type": "object",
      "description": "An empty document whose existence at /roles_admin/{userId} grants a user admin privileges.",
      "properties": {}
    },
    "Username": {
      "title": "Username",
      "type": "object",
      "description": "A public mapping from a username to a user's UID.",
      "properties": {
        "uid": {
          "type": "string",
          "description": "The UID of the user."
        }
      },
      "required": [
        "uid"
      ]
    },
    "RefundRequest": {
        "title": "Refund Request",
        "type": "object",
        "description": "Represents a user's request for a refund based on the success guarantee.",
        "properties": {
            "id": { "type": "string", "description": "Unique ID for the refund request." },
            "userId": { "type": "string", "description": "The UID of the user requesting the refund." },
            "userUsername": { "type": "string", "description": "The username of the user requesting the refund." },
            "userEmail": { "type": "string", "format": "email", "description": "The email of the user requesting the refund." },
            "requestDate": { "type": "string", "format": "date-time", "description": "Timestamp when the request was made." },
            "status": { "type": "string", "enum": ["pending", "processed", "denied"], "description": "The current status of the refund request." },
            "referralCountAtRequest": { "type": "number", "description": "The number of referrals the user had at the time of the request." }
        },
        "required": ["userId", "userUsername", "userEmail", "requestDate", "status", "referralCountAtRequest"]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.  Path-based ownership: Only the user with the matching {userId} can read/write their profile.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/subscriptionTiers/{subscriptionTierId}",
        "definition": {
          "entityName": "SubscriptionTier",
          "schema": {
            "$ref": "#/backend/entities/SubscriptionTier"
          },
          "description": "Stores subscription tier details (publicly readable).",
          "params": [
            {
              "name": "subscriptionTierId",
              "description": "The unique identifier for the subscription tier."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/subscriptions/{subscriptionId}",
        "definition": {
          "entityName": "Subscription",
          "schema": {
            "$ref": "#/backend/entities/Subscription"
          },
          "description": "Stores a user's subscriptions. Path-based ownership: Only the user with the matching {userId} can manage their subscriptions.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "subscriptionId",
              "description": "The unique identifier for the subscription."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/referrals/{referralId}",
        "definition": {
          "entityName": "Referral",
          "schema": {
            "$ref": "#/backend/entities/Referral"
          },
          "description": "Stores referrals made by a user. A newly signed up user is allowed to create this document in their referrer's subcollection. This is validated by checking data within the request, avoiding a complex `get` call.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user (the referrer)."
            },
            {
              "name": "referralId",
              "description": "The unique identifier for the referral."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/payments/{paymentId}",
        "definition": {
          "entityName": "Payment",
          "schema": {
            "$ref": "#/backend/entities/Payment"
          },
          "description": "Stores payment history for a user. Path-based ownership: Only the user with the matching {userId} can view their payment history.  The admin also has access to the payments, since this is required for payouts.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "paymentId",
              "description": "The unique identifier for the payment."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "AdminRole",
          "schema": {
            "$ref": "#/backend/entities/AdminRole"
          },
          "description": "Documents in this collection indicate admin privileges. A user can read their own document here to check for admin status.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the admin user."
            }
          ]
        }
      },
      {
        "path": "/usernames/{username}",
        "definition": {
          "entityName": "Username",
          "schema": {
            "$ref": "#/backend/entities/Username"
          },
          "description": "Publicly readable mapping of usernames to user IDs to facilitate referrals. Users can create their own entry, but not modify it or others'. The create rule is simplified to prevent timing issues during signup.",
          "params": [
            {
              "name": "username",
              "description": "The user's unique username."
            }
          ]
        }
      },
      {
        "path": "/refundRequests/{requestId}",
        "definition": {
          "entityName": "RefundRequest",
          "schema": {
            "$ref": "#/backend/entities/RefundRequest"
          },
          "description": "Stores user refund requests. Users can create their own, admins can manage all.",
          "params": [
            {
              "name": "requestId",
              "description": "The unique ID for the refund request."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support Affiliate AI Host's affiliate marketing and subscription management features, prioritizing security, scalability, and ease of debugging. The key principle is Authorization Independence, achieved through denormalization of authorization data, eliminating the need for `get()` calls in security rules where possible. This ensures atomic operations and simplifies security rule logic. Data is segregated into collections with homogeneous security postures, enabling secure list operations. User-owned data is organized under user-specific paths for simplified ownership-based security. The use of DBAC (database-based access control) via the `/roles_admin` collection eliminates the need for custom claims."
  }
}
