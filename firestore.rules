rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a strict user-ownership model, where
     * all user-generated data (subscriptions, referrals, etc.) is stored in
     * subcollections under that user's own document. This approach simplifies
     * security logic by tying access control directly to the document path. A
     * database-based admin role is implemented via the `/roles_admin`
     * collection, granting admins specific oversight over payments and commissions.
     *
     * Data Structure:
     * - /users/{userId}/... : A user's private data tree.
     * - /subscriptionTiers/{tierId} : Publicly readable, admin-managed data.
     * - /roles_admin/{userId} : A private lookup collection to grant admin rights.
     *
     * Key Security Decisions:
     * - User data is strictly segregated. Users can only access documents within
     *   their own `/users/{userId}` path. Listing other users is disallowed.
     * - An `isAdmin()` function checks for a document in `/roles_admin` to grant
     *   elevated privileges, primarily for managing payouts and commissions.
     * - Subscription tiers are public for read operations but cannot be modified
     *   by any client, ensuring data integrity.
     *
     * Denormalization for Authorization:
     * Path-based ownership (`/users/{userId}/...`) is the primary strategy,
     * avoiding the need for `get()` calls to check parent documents. The admin
     * role is managed through a dedicated `/roles_admin/{userId}` collection, a
     * highly performant pattern for checking roles without custom claims.
     *
     * Structural Segregation:
     * Private user data (e.g., `/users/{userId}/subscriptions`) is structurally
     * separate from public data (`/subscriptionTiers`), which makes list
     * operations on both collections simple, secure, and performant.
     */

    // =====================================================================
    // Helper Functions
    // =====================================================================

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document being operated on already exists.
     * Crucial for protecting against writes on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }
    
    /**
     * Checks if the user has an admin role by looking for their UID in the
     * /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if a user is either the owner of the resource or an admin.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }
    
    /**
     * Combines owner/admin check with an existence check for state-changing operations.
     */
    function isExistingOwnerOrAdmin(userId) {
      return isOwnerOrAdmin(userId) && isExistingDoc();
    }

    // =====================================================================
    // Collection Rules
    // =====================================================================

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user creating their own profile document. `auth.uid` must match `userId`.
     * @deny (list) Any user trying to list all user documents.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Defines subscription tiers. This data is public for all to read.
     * @path /subscriptionTiers/{subscriptionTierId}
     * @allow (get) Any user, signed in or not, reading the details of a subscription tier.
     * @deny (create) Any client trying to create a new subscription tier. This is an admin-only task via a backend SDK.
     * @principle Provides public read access to global configuration data while prohibiting all client-side writes.
     */
    match /subscriptionTiers/{subscriptionTierId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages user subscriptions, nested under the user's document.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (create) A user creating a new subscription for themselves. The `userId` in the data must match the path.
     * @deny (get) A user trying to read another user's subscription details.
     * @principle Enforces path-based ownership for all reads and writes, ensuring users can only manage their own subscriptions.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.userId == resource.data.userId;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Stores referrals made by a user (the referrer).
     * @path /users/{userId}/referrals/{referralId}
     * @allow (create) A referrer creating a referral record under their own user ID.
     * @deny (update) Any user trying to change the `referrerId` of an existing referral.
     * @principle Enforces path-based ownership for the user who made the referral.
     */
    match /users/{userId}/referrals/{referralId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.referrerId == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.referrerId == resource.data.referrerId;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Contains payment history for a user, accessible by the user and admins.
     * @path /users/{userId}/payments/{paymentId}
     * @allow (get) An admin reading a user's payment history to process a payout.
     * @deny (get) A standard user trying to read another user's payment history.
     * @principle Grants access to either the document owner or an administrator.
     */
    match /users/{userId}/payments/{paymentId} {
      allow get: if isOwnerOrAdmin(userId);
      allow list: if isOwnerOrAdmin(userId);
      allow create: if isOwnerOrAdmin(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwnerOrAdmin(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwnerOrAdmin(userId);
    }

    /**
     * @description Stores commissions earned by an affiliate, accessible by the affiliate and admins.
     * @path /users/{affiliateId}/commissions/{commissionId}
     * @allow (list) An affiliate listing their own earned commissions.
     * @deny (list) An affiliate trying to list another user's commissions.
     * @principle Grants access to either the document owner (the affiliate) or an administrator.
     */
    match /users/{affiliateId}/commissions/{commissionId} {
      allow get: if isOwnerOrAdmin(affiliateId);
      allow list: if isOwnerOrAdmin(affiliateId);
      allow create: if isOwnerOrAdmin(affiliateId) && request.resource.data.affiliateId == affiliateId;
      allow update: if isExistingOwnerOrAdmin(affiliateId) && request.resource.data.affiliateId == resource.data.affiliateId;
      allow delete: if isExistingOwnerOrAdmin(affiliateId);
    }

    /**
     * @description Lookup collection for admin roles. Existence of a doc grants admin rights.
     * @path /roles_admin/{userId}
     * @allow (get) No client is ever allowed to read this collection, to prevent enumeration of admins.
     * @deny (create) No client is allowed to write to this collection. Admin roles are granted via the Firebase Console or an Admin SDK.
     * @principle Implements database-based access control (DBAC) by denying all client access. It is used only by other rules via `exists()`.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}